for(let i = 0; i < 5; i++){
  var x = 10;
}


console.log(x)

// ბლოკი არის {} - ში მოთავსებული რაღაც კოდი/ნებისმიერი კოდი
//var-ს არ გააჩნია Block Scope/ბლოკის საზღვარი/ფარგლები
//გამოდის რომ მას თუარ გაანია ბლოკის საზღვრები, მისი გამოყენება მაინც შემიძლია ანუ ესნიშნავს რომ ჩვენ var keywords არ გააჩნია block scop ამის შედეგად შეგვიძლია x ცვლადი შეგვიძლია გამოვიყენოთ ეს იმას ნიშნავს რომ მას ბლოკური ფარგლები არ გააჩნია



//მაგრამ let და const block scope გაანია ამიტომ მათ ვერ გამოვიყენებთ ფუნქციის გარეთ

//-----------------------

function func(){
  var x = 10;
}

console.log(x)

//varkeywords გაანია ფუნქციის ზღვარი ამიტომაც ცვლადს ვერ გამოვიყენებთ ფუნქციის გარ
//var keywords შეგვიძლია შევუცვალოთ თავისი მნიშვნელობა.

//-----------------------------

for(var i = 0; i < 10; i++){
  consolge.log(i)
}

var i = 15

//var keywordshi ცუდი ის არის რომ არ გააჩნია block scope
//ამ შემთვევაში ეს კოდი ერორს არ გამოგვიტანს მაგრამ არ შეიძლება ასე დაწერა



//--------------------



//no error here but it will output 15 and we dont want that
var i = 10; 

i = 16 // რეინილიზაცია

var i = 15; // რედეკლარაცია

//1 მიზეზი: საბოლოო ჯამში var keyword იმიტომ არის ცუდი რომ მისი რედეკლარირება შეგვიძლია

// 2 რედეკლარაცია არის ცუდი რადგანვერ მოვახდენთ ოპტიმიზაციას კოდი ჯავასკრიპტში

//----------------
console.log(i)

var i = 15
//result: undefined. --instead of error


// 3: იქამდე შეგვიძ₾ია var-ით შექმნილი ცვლადის გამოყენება სანამ მისი მნიშვნელობა გაწერილი არ იქნება


console.log(i)

const i = 15; //result: ERROR



//--------

//Hoisting არისკონკრეტული დეკლარაცია ავტომატურად გადაინაცვლებს სულ თავში
//ნებისმიერ ფუნქციის დეკლარაცია და var ით შექმნილი ცვლადის დეკლარაციები ავტომატურად გადადის ზედა ნაწილში

//3 მიზეზი რატომაც არის ცუდი var keyword გამოყენება simplified:
  //1; არ გააჩნია ბლოკური ფარგლები.
  //2; შეგვიძლია მისი რედეკლარაცია
  //3; მასზე მოქმედებს Hoisting effect-ი
      //(სანამ ცვლადი შეიქმნეება მანამ შემიძლია მისი გამოყენება)
  
  
  //ეს 3 მიზეზი არანაირად არ მოქმედებს არც let-ზე და არც const-ზე


  //-------------------------

  //ასევე var keyword ემატება window() ობიექტს რომელიც ძალიან ცუდია, ანუ ეს არის გლობალური ფარგლები/global scope რომელიც იყენებს ზედმეტ რესურსებს. 
  //window() შეგვიძლია ყველგან გამოვყენოთ რადგან ის არის გლობალურად ხელმისაწვდომი